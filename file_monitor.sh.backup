#!/usr/bin/env bash

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Default configuration
CHECK_INTERVAL=2
LOG_FILE=""
declare -A CHECKSUMS

display_help() {
    echo "File Change Detector - Monitor files for modifications"
    echo ""
    echo "Usage: $0 [OPTIONS] FILE [FILE2 FILE3 ...]"
    echo ""
    echo "Options:"
    echo "  -i SECONDS    Set check interval (default: 2 seconds)"
    echo "  -l LOGFILE    Log changes to specified file"
    echo "  -h            Display this help message"
    echo ""
    echo "Examples:"
    echo "  $0 config.txt"
    echo "  $0 -i 5 config.txt data.txt"
    echo "  $0 -l monitor.log config.txt"
    exit 0
}

log_message() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local output="[$timestamp] $message"
    
    echo -e "$output"
    
    if [[ -n "$LOG_FILE" ]]; then
        echo "$output" >> "$LOG_FILE"
    fi
}

calculate_checksum() {
    local file="$1"
    
    if command -v md5sum &> /dev/null; then
        md5sum "$file" 2>/dev/null | awk '{print $1}'
    elif command -v md5 &> /dev/null; then
        md5 -q "$file" 2>/dev/null
    else
        shasum "$file" 2>/dev/null | awk '{print $1}'
    fi
}

validate_file() {
    local file="$1"
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}Error: File '$file' does not exist${NC}" >&2
        return 1
    fi
    
    if [[ ! -r "$file" ]]; then
        echo -e "${RED}Error: File '$file' is not readable${NC}" >&2
        return 1
    fi
    
    return 0
}

initialize_monitoring() {
    local files=("$@")
    
    log_message "${BLUE}Starting file monitor...${NC}"
    
    for file in "${files[@]}"; do
        if validate_file "$file"; then
            CHECKSUMS["$file"]=$(calculate_checksum "$file")
            log_message "${GREEN}Monitoring: $file${NC}"
        else
            exit 1
        fi
    done
    
    log_message "${YELLOW}Press Ctrl+C to stop monitoring${NC}"
    echo ""
}

check_for_changes() {
    local files=("$@")
    
    for file in "${files[@]}"; do
        if [[ ! -f "$file" ]]; then
            log_message "${RED}Warning: File '$file' no longer exists${NC}"
            continue
        fi
        
        local current_checksum=$(calculate_checksum "$file")
        
        if [[ "$current_checksum" != "${CHECKSUMS[$file]}" ]]; then
            log_message "${RED}File $file has been modified.${NC}"
            CHECKSUMS["$file"]="$current_checksum"
        fi
    done
}

cleanup() {
    echo ""
    log_message "${YELLOW}Monitoring stopped.${NC}"
    exit 0
}

trap cleanup SIGINT SIGTERM

while getopts "i:l:h" opt; do
    case $opt in
        i)
            CHECK_INTERVAL=$OPTARG
            if ! [[ "$CHECK_INTERVAL" =~ ^[0-9]+$ ]]; then
                echo -e "${RED}Error: Check interval must be a positive integer${NC}" >&2
                exit 1
            fi
            ;;
        l)
            LOG_FILE=$OPTARG
            mkdir -p "$(dirname "$LOG_FILE")"
            ;;
        h)
            display_help
            ;;
        \?)
            echo -e "${RED}Invalid option: -$OPTARG${NC}" >&2
            exit 1
            ;;
    esac
done

shift $((OPTIND-1))

if [[ $# -eq 0 ]]; then
    echo -e "${RED}Error: No files specified to monitor${NC}" >&2
    echo "Use -h for help"
    exit 1
fi

MONITORED_FILES=("$@")

initialize_monitoring "${MONITORED_FILES[@]}"

while true; do
    check_for_changes "${MONITORED_FILES[@]}"
    sleep "$CHECK_INTERVAL"
done
